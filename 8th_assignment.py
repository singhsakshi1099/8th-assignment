# -*- coding: utf-8 -*-
"""8th assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ROhHBFdKYyhusgkyTjKlCn8mle2diQnl
"""

#first solution
def minimumDeleteSum(s1, s2):
    m, n = len(s1), len(s2)

    # Initialize the table
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Fill in the table
    for i in range(1, m + 1):
        dp[i][0] = dp[i-1][0] + ord(s1[i-1])
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j-1] + ord(s2[j-1])

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))

    return dp[m][n]

#second solution
def checkValidString(s):
    stack = []
    star_stack = []

    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        elif char == '*':
            star_stack.append(i)
        else:
            if stack:
                stack.pop()
            elif star_stack:
                star_stack.pop()
            else:
                return False

    while stack and star_stack:
        if stack[-1] > star_stack[-1]:
            return False
        stack.pop()
        star_stack.pop()

    return len(stack) == 0

#third solution
def minDistance(word1, word2):
    m, n = len(word1), len(word2)

    # Initialize the table
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Fill in the table
    for i in range(1, m + 1):
        dp[i][0] = dp[i-1][0] + 1
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j-1] + 1

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)

    return dp[m][n]

#fifth solution
def compress(chars):
    # Initialize pointers and counters
    write_ptr = 0
    read_ptr = 0
    count = 0

    # Iterate through the array
    while read_ptr < len(chars):
        curr_char = chars[read_ptr]
        count = 1

        # Count the consecutive repeating characters
        while read_ptr + 1 < len(chars) and chars[read_ptr + 1] == curr_char:
            read_ptr += 1
            count += 1

        # Write the compressed character(s) to the array
        chars[write_ptr] = curr_char
        write_ptr += 1

        # Write the count if it's greater than 1
        if count > 1:
            count_str = str(count)
            for digit in count_str:
                chars[write_ptr] = digit
                write_ptr += 1

        # Move the read pointer to the next character
        read_ptr += 1

    return write_ptr

#sixth solution
from collections import Counter

def findAnagrams(s, p):
    result = []
    p_freq = Counter(p)  # Frequency map for characters in p
    window_freq = Counter(s[:len(p)])  # Frequency map for characters in the initial window

    # Check if the initial window is an anagram of p
    if p_freq == window_freq:
        result.append(0)

    # Slide the window over the remaining characters of s
    for i in range(len(p), len(s)):
        # Update the frequency map by adding the current character
        window_freq[s[i]] += 1

        # Remove the character that is no longer in the window
        if window_freq[s[i - len(p)]] == 1:
            del window_freq[s[i - len(p)]]
        else:
            window_freq[s[i - len(p)]] -= 1

        # Check if the window is an anagram of p
        if p_freq == window_freq:
            result.append(i - len(p) + 1)

    return result

#seventh solution
def decodeString(s):
    stack = []
    current_str = ""
    current_num = 0

    for char in s:
        if char.isdigit():
            current_num = current_num * 10 + int(char)
        elif char == "[":
            stack.append(current_str)
            stack.append(current_num)
            current_str = ""
            current_num = 0
        elif char == "]":
            num = stack.pop()
            prev_str = stack.pop()
            current_str = prev_str + num * current_str
        else:
            current_str += char

    return current_str

#eighth solution
def buddyStrings(s, goal):
    if len(s) != len(goal):
        return False

    if s == goal:
        # Check if there are at least two same characters in s
        seen = set()
        for char in s:
            if char in seen:
                return True
            seen.add(char)
        return False

    diff_indices = []
    for i in range(len(s)):
        if s[i] != goal[i]:
            diff_indices.append(i)

    if len(diff_indices) != 2:
        return False

    i, j = diff_indices
    swapped = list(s)
    swapped[i], swapped[j] = swapped[j], swapped[i]
    swapped = "".join(swapped)

    return swapped == goal